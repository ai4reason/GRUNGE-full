(defvar *oh* (make-hash-table :test #'equal))

(setq *ignore* '("c_2Ebool_2E_20___20fakeconst4_2Ecase_2CS10_2Ecase_20magic_2C7_2Edefault" "c_2Ebool_2E_20___20fakeconst5_2Earrow_2CS10_2Ecase_20magic_2C7_2Edefault" "c_2Ebool_2E_20___20fakeconst5_2Esplit_2CS10_2Ecase_20magic_2C7_2Edefault"))
(setq *primtypes* '("ty_2Emin_2Ebool" "ty_2Emin_2Eind"))
(setq *artype* "ty_2Emin_2Efun")
(setq *eq* "c_2Emin_2E_3D")
(setq *imp* "c_2Emin_2E_3D_3D_3E")
(setq *choice* "c_2Emin_2E_40")
(setq *all* "c_2Ebool_2E_21")
(setq *and* "c_2Ebool_2E_2F_5C")
(setq *ex* "c_2Ebool_2E_3F")
(setq *exu* "c_2Ebool_2E_3F_21")

(setq *typearity* (make-hash-table :test #'equal))
(setq *consttpvars* (make-hash-table :test #'equal))
(setq *consttp* (make-hash-table :test #'equal))
(setq *foconst* (make-hash-table :test #'equal))
(setq *proptpvars* (make-hash-table :test #'equal))
(setq *prop* (make-hash-table :test #'equal))

(setq *currname* nil)
(setq *sigdeps* (make-hash-table :test #'equal))

(setq *lamliftcount* 0)
(setq *lamlift* (make-hash-table :test #'equal))

; just always put parentheses and let god sort them out
(defun par (p q s) (if (or t (< p q)) (format nil "( ~d )" s) s))

(defun almostequal (r s)
  (let ((i 0)
	(j 0)
	(e t))
    (loop while (and e (< i (length r)) (< j (length s))) do
	  (if (member (aref r i) '(#\( #\) #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\space #\tab
				   #\a #\b #\c #\d #\e #\f))
	      (incf i)
	    (if (member (aref s j) '(#\( #\) #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9 #\space #\tab
				     #\a #\b #\c #\d #\e #\f))
		(incf j)
	      (if (eq (aref r i) (aref s j)) (progn (incf i) (incf j)) (setq e nil)))))
    (and e (= i (length r)) (= j (length s)))))

(defun tp-tpvars (a)
  (if (consp a)
      (if (eq (car a) 'ARR)
	  (union (tp-tpvars (cadr a)) (tp-tpvars (caddr a)) :test #'equal)
	(let ((vl nil))
	  (dolist (b (cdr a) vl)
	    (setq vl (union vl (tp-tpvars b) :test #'equal)))))
    (if (and (stringp a) (not (gethash a *typearity*)))
	(list a)
      nil)))

(defun tm-tpvars (m ctx)
  (if (consp m)
      (cond ((eq (car m) 'AP) (union (tm-tpvars (cadr m) ctx) (tm-tpvars (caddr m) ctx) :test #'equal))
	    ((eq (car m) 'LAMBDA) (tm-tpvars (cadddr m) (acons (cadr m) (caddr m) ctx)))
	    ((eq (car m) 'TPSUBST)
	     (let ((vl nil))
	       (dolist (b (caddr m) vl)
		 (setq vl (union vl (tp-tpvars (cdr b)) :test #'equal)))))
	    (t (break)))
    (let ((z (assoc m ctx :test #'equal)))
      (if z
	  (tp-tpvars (cdr z))
	nil))))

(defun tm-frees (m ctx)
  (if (consp m)
      (cond ((eq (car m) 'AP) (union (tm-frees (cadr m) ctx) (tm-frees (caddr m) ctx) :test #'equal))
	    ((eq (car m) 'LAMBDA) (remove (cadr m) (tm-frees (cadddr m) (acons (cadr m) (caddr m) ctx)) :test #'equal))
	    ((eq (car m) 'TPSUBST) nil)
	    (t (break)))
    (let ((z (assoc m ctx :test #'equal)))
      (if z (list m) nil))))

(defun tpsubst-tp (a theta)
  (if (consp a)
      (if (eq (car a) 'ARR)
	  (list 'ARR (tpsubst-tp (cadr a) theta) (tpsubst-tp (caddr a) theta))
	(cons (car a) (mapcar #'(lambda (a) (tpsubst-tp a theta)) (cdr a))))
    (let ((b (assoc a theta :test #'equal)))
      (if b
	  (cdr b)
	a))))

(defun noarr-p (a) (if (consp a) (if (eq (car a) 'ARR) nil (noarrl-p (cdr a))) t))
(defun noarrl-p (al) (if al (and (noarr-p (car al)) (noarrl-p (cdr al))) t))
(defun notpvar-p (a) (if (consp a) (notpvarl-p (cdr a)) (if (numberp a) nil t)))
(defun notpvarl-p (al) (if al (and (notpvar-p (car al)) (notpvarl-p (cdr al))) t))
(setq *usespecialtypes* t)
(setq *newspecialtypes* nil)
(setq *specialtypes* (make-hash-table :test #'equal))
(setq *specialtypesnamerev* (make-hash-table :test #'equal))

(setq *tph* (make-hash-table :test #'equal))

(defun transl-tp-2 (a tvars)
  (when (and *currname* (gethash a *specialtypes*)) (push (gethash a *specialtypes*) (gethash *currname* *sigdeps*)))
  (cond ((consp a)
	 (if (or (eq (car a) 'FUN) (equal (car a) *artype*))
	     (list 'ARR (transl-tp (cadr a) tvars) (transl-tp (caddr a) tvars))
	   (let ((n (gethash (car a) *typearity*)))
	     (unless n (format t "ERROR: Do not know arity of type constructor ~d~%" (car a)) (break))
	     (unless (equal n (length (cdr a))) (format t "Type constructor applied to ~d types but expected ~d~%" (length (cdr a)) n) (break))
	     (when *currname* (push (car a) (gethash *currname* *sigdeps*)))
	     (cons (car a) (mapcar #'(lambda (b) (transl-tp b tvars)) (cdr a))))))
	((equal a "ty_2Emin_2Ebool") 'BOOL)
	((equal a "ty_2Emin_2Eind") 'IND)
	((member a tvars :test #'equal) a)
	((equal (gethash a *typearity*) 0) (when *currname* (push a (gethash *currname* *sigdeps*))) a)
	(t (setq *a* a) (format t "ERROR: Cannot interpret ~d as a type~%" a) (break))))

(defun foishtp-p (a) (if (consp a) (if (and (eq (car a) 'ARR) (gethash (cadr a) *specialtypes*)) (foishtp-p (caddr a))) (gethash a *specialtypes*)))

(defun specialtypesuff (z)
  (if (consp z)
      (format nil "c_~d~d" (car z) (specialtypesuff-l (cdr z)))
    (case z
      (BOOL "o")
      (IND "i")
      (t (format nil "~d" z)))))

(defun specialtypesuff-l (l)
  (if l
      (format nil "_~d~d" (specialtypesuff (car l)) (specialtypesuff-l (cdr l)))
    ""))

(defun special-type-sigdeps (x a)
  (if (consp a)
      (if (eq (car a) 'ARR)
	  (progn
	    (special-type-sigdeps x (cadr a))
	    (special-type-sigdeps x (caddr a)))
	(progn
	  (push (car a) (gethash x *sigdeps*))
	  (dolist (b (cdr a)) (special-type-sigdeps x b))))
    (when (stringp a)
      (push a (gethash x *sigdeps*)))))

(defun transl-tp (a tvars)
  (let ((b (transl-tp-2 a tvars))
	(theta nil)
	(i 0))
    (dolist (x tvars) (push (cons x (incf i)) theta))
    (let ((z (tpsubst-tp b theta)))
      (when (and (not (gethash z *specialtypes*)) *usespecialtypes* (noarr-p z) (notpvar-p z))
	(unless (and *outputthf0* (eq z 'BOOL))
	  (setf (gethash z *specialtypes*) (specialtypesuff z))
	  (setf (gethash (specialtypesuff z) *specialtypesnamerev*) z)
	  (special-type-sigdeps (gethash z *specialtypes*) z)
	  (push z *newspecialtypes*)))
      (when (and *currname* (gethash z *specialtypes*)) (push (gethash z *specialtypes*) (gethash *currname* *sigdeps*)))
      (setf (gethash (tpsubst-tp b theta) *tph*) t)
      b)))

(defun transl-ptp (a)
  (if (and (consp a) (eq (car a) 'FORALL_TYVARL_TYPE))
      (values (transl-tp (caddr a) (cadr a)) (cadr a))
    (values (transl-tp a nil) nil)))

(defun transl-tm (m tpvars tmvars)
  (setq *m99* m)
  (if (consp m)
      (let ((h (car m))
	    (args (cdr m)))
	(cond ((member h tmvars :test #'equal)
	       (loop while (member (car args) tpvars :test #'equal) do (pop args))
	       (transl-spine h args tpvars tmvars))
	      ((eq h 'LAMBDA)
	       (unless (stringp (car args))
		 (setq *m* m *tpvars* tpvars *tmvars* tmvars)
		 (format t "WARNING: lam not var")
		 (break))
	       (when (cdddr args)
		 (setq *m* m *tpvars* tpvars *tmvars* tmvars)
		 (format t "WARNING: lam two bodies")
		 (break))
	       (list 'LAMBDA (car args) (transl-tp (cadr args) tpvars) (transl-tm (caddr args) tpvars (cons (car args) tmvars))))
	      ((consp h)
	       (transl-spine (transl-tm h tpvars tmvars) args tpvars tmvars))
	      ((gethash h *consttp*)
	       (when *currname* (push h (gethash *currname* *sigdeps*)))
	       (let ((tptheta nil))
		 (dolist (x (gethash h *consttpvars*))
		   (unless args (format t "ERROR: not enough tp args ~d~%" m) (setq *m* m) (break))
		   (let ((atp (transl-tp (car args) tpvars)))
		     (push (cons x atp) tptheta)
		     (pop args)))
		 (transl-spine (list 'TPSUBST h tptheta) args tpvars tmvars)))
	      (t
	       (setq *m* m *tpvars* tpvars *tmvars* tmvars)
	       (format t "WARNING: unexpected tm case 1")
	       (break))))
    (if (member m tmvars :test #'equal)
	m
      (if (gethash m *consttp*)
	  (if (gethash m *consttpvars*)
	      (progn
		(setq *m* m *tpvars* tpvars *tmvars* tmvars)
		(format t "WARNING: unexpected tm case 3")
		(break))
	    (progn
	      (when *currname* (push m (gethash *currname* *sigdeps*)))
	      m))
	(progn
	  (setq *m* m *tpvars* tpvars *tmvars* tmvars)
	  (format t "WARNING: unexpected tm case 2")
	  (break))))))

(defun transl-spine (f ml tpvars tmvars)
  (if ml
      (transl-spine (list 'AP f (transl-tm (car ml) tpvars tmvars)) (cdr ml) tpvars tmvars)
    f))

(defun transl-prop (p)
  (if (and (consp p) (eq (car p) 'FORALL_TYVARL_TERM))
      (let ((q (transl-tm (caddr p) (cadr p) nil)))
	(values q (cadr p)))
    (values (transl-tm p nil nil) nil)))

(defun tm-tp (m &optional ctx)
  (setq *m98* m)
  (if (consp m)
      (cond ((eq (car m) 'AP)
	     (let ((ab (tm-tp (cadr m) ctx))
		   (a (tm-tp (caddr m) ctx)))
	       (if (and (consp ab) (eq (car ab) 'ARR))
		   (if (equal (cadr ab) a)
		       (caddr ab)
		     (error "func app to tm of wrong type"))
		 (error "non func applied"))))
	    ((eq (car m) 'LAMBDA)
	     (let* ((a (caddr m))
		    (b (tm-tp (cadddr m) (acons (cadr m) a ctx))))
	       (list 'ARR a b)))
	    ((eq (car m) 'TPSUBST)
	     (let* ((c (cadr m))
		    (theta (caddr m))
		    (tvars (gethash c *consttpvars*)))
	       (dolist (v tvars) (unless (assoc v theta :test #'equal) (error (format nil "unbound tpvar ~d in ~d" v m))))
	       (tpsubst-tp (gethash c *consttp*) theta)))
	    (t
	     (error (format nil "do not know how to give type for ~d~%" m))))
    (let ((a (assoc m ctx :test #'equal)))
      (if a
	  (cdr a)
	(if (and (gethash m *consttp*) (not (gethash m *consttpvars*)))
	    (gethash m *consttp*)
	  (error (format nil "do not know how to give type for ~d~%" m)))))))

(setq *outputthf0* t)

(defun ap-to-tps-thf0 (s al)
  (if al
      (ap-to-tps-thf0 (format nil "~d@~d" s (tp-thf0 (car al))) (cdr al))
    s))

(defun ap-to-tps-tff0 (s al)
  (if al
      (let ((sp (tp-tff0 (car al))))
	(dolist (a (cdr al))
	  (setq sp (format nil "~d,~d" sp (tp-tff0 a))))
	(format nil "~d(~d)" s sp))
    s))

(defun tp-thf0 (a)
  (if (consp a)
      (if (eq (car a) 'ARR)
	  (format nil "(arr@~d@~d)" (tp-thf0 (cadr a)) (tp-thf0 (caddr a)))
	(if (stringp (car a))
	    (if (cdr a)
		(format nil "(~d)" (ap-to-tps-thf0 (car a) (cdr a)))
	      (car a))
	  (break)))
    (if (eq a 'BOOL)
	"bool"
      (if (eq a 'IND)
	  "ind"
	(if (stringp a)
	    a
	  (break))))))

(defun tp-tff0 (a)
  (if (consp a)
      (if (eq (car a) 'ARR)
	  (format nil "arr(~d,~d)" (tp-tff0 (cadr a)) (tp-tff0 (caddr a)))
	(if (stringp (car a))
	    (if (cdr a)
		(ap-to-tps-tff0 (car a) (cdr a))
	      (car a))
	  (break)))
    (if (eq a 'BOOL)
	"bool"
      (if (eq a 'IND)
	  "ind"
	(if (stringp a)
	    a
	  (break))))))

(defun tm-head-spine (m &optional sp)
  (if (and (consp m) (eq (car m) 'AP))
      (tm-head-spine (cadr m) (cons (caddr m) sp))
    (values m sp)))

(defun numargstp (ftp &optional (i 0))
  (if (and (consp ftp) (eq (car ftp) 'ARR))
      (numargstp (caddr ftp) (1+ i))
    i))

(defun stm-thf0 (m a ctx vctx)
  (multiple-value-bind
      (h sp)
      (tm-head-spine m)
    (let ((z (assoc h vctx :test #'equal)))
      (if z
	  (if (and (null sp) (equal (caddr z) a))
	      (cadddr z)
	    (format nil "(surj__~d @ ~d)" (gethash a *specialtypes*) (tm-thf0 m ctx vctx)))
	(if (and (gethash h *foconst*) (= (length sp) (numargstp (gethash h *consttp*))))
	    (stm-thf0-ap (format nil "fo__~d" h) sp (gethash h *consttp*) ctx vctx)
	  (format nil "(surj__~d @ ~d)" (gethash a *specialtypes*) (tm-thf0 m ctx vctx)))))))

(defun stm-thf0-ap (h sp ftp ctx vctx)
  (if (and (consp ftp) (eq (car ftp) 'ARR))
      (if sp
	  (stm-thf0-ap (format nil "(~d @ ~d)" h (stm-thf0 (car sp) (cadr ftp) ctx vctx))
		       (cdr sp)
		       (caddr ftp)
		       ctx vctx)
	(progn (error "impossible 83927")))
    (if sp
	(progn (error "impossible 83928"))
      h)))

(defun tm-thf0 (m &optional ctx vctx)
  (let ((a (tm-tp m ctx)))
    (if (gethash a *specialtypes*)
	(multiple-value-bind
	    (h sp)
	    (tm-head-spine m)
	  (if (and (gethash h *foconst*) (= (length sp) (numargstp (gethash h *consttp*))))
	      (format nil "(inj__~d @ ~d)" (gethash a *specialtypes*) (stm-thf0-ap (format nil "fo__~d" h) sp (gethash h *consttp*) ctx vctx))
	    (tm-thf0-2 m ctx vctx)))
      (tm-thf0-2 m ctx vctx))))
  
(defun tm-thf0-2 (m &optional ctx vctx)
  (if (consp m)
      (cond ((eq (car m) 'AP)
	     (format nil "(ap@~d@~d)" (tm-thf0-2 (cadr m) ctx vctx) (tm-thf0 (caddr m) ctx vctx)))
	    ((eq (car m) 'LAMBDA)
	     (format nil "(lam@~d@(^ [~d:$i] : ~d))"
		     (tp-thf0 (caddr m))
		     (cadr m)
		     (tm-thf0 (cadddr m)
			      (acons (cadr m) (caddr m) ctx)
			      (cons (list (cadr m) (cadr m) nil) vctx)
			      )))
	    ((eq (car m) 'TPSUBST)
	     (let* ((c (cadr m))
		    (theta (caddr m))
		    (tvars (gethash c *consttpvars*))
		    (ral nil))
	       (dolist (v tvars) (let ((a (assoc v theta :test #'equal))) (unless a (break)) (push (cdr a) ral)))
	       (if ral
		   (format nil "(~d)" (ap-to-tps-thf0 c (reverse ral)))
		 (format nil "~d" c))))
	    (t (break)))
    (let ((z (assoc m vctx :test #'equal)))
      (if z
	  (cadr z)
	(format nil "~d" m)))))

(defun eqn-p (m)
  (and (consp m)
       (eq (car m) 'AP)
       (consp (cadr m))
       (eq (caadr m) 'AP)
       (consp (cadr (cadr m)))
       (eq (caadr (cadr m)) 'TPSUBST)
       (equal (cadr (cadr (cadr m))) "c_2Emin_2E_3D")))

(defun equiv-p (m)
  (and (consp m)
       (eq (car m) 'AP)
       (consp (cadr m))
       (eq (caadr m) 'AP)
       (consp (cadr (cadr m)))
       (equal (cadr (cadr m)) '(TPSUBST "c_2Emin_2E_3D" (("A_27a" . BOOL))))))

(defun sortofis (m x)
  (or (equal m x)
      (and (consp m)
	   (eq (car m) 'TPSUBST)
	   (equal (cadr m) x)
	   (null (caddr m)))))

(defun imp-p (m)
  (and (consp m)
       (eq (car m) 'AP)
       (consp (cadr m))
       (eq (caadr m) 'AP)
       (sortofis (cadr (cadr m)) "c_2Emin_2E_3D_3D_3E")))

(defun all-p (m)
  (and (consp m)
       (eq (car m) 'AP)
       (consp (cadr m))
       (eq (caadr m) 'TPSUBST)
       (equal (cadr (cadr m)) "c_2Ebool_2E_21")
       (consp (caddr m))
       (eq (caaddr m) 'LAMBDA)))

(defun ex-p (m)
  (and (consp m)
       (eq (car m) 'AP)
       (consp (cadr m))
       (eq (caadr m) 'TPSUBST)
       (equal (cadr (cadr m)) "c_2Ebool_2E_3F")
       (consp (caddr m))
       (eq (caaddr m) 'LAMBDA)))

; unused since there is no ?! in THF0
(defun exu-p (m)
  (and (consp m)
       (eq (car m) 'AP)
       (consp (cadr m))
       (eq (caadr m) 'TPSUBST)
       (equal (cadr (cadr m)) "c_2Ebool_2E_3F_21")
       (consp (caddr m))
       (eq (caaddr m) 'LAMBDA)))

(defun and-p (m)
  (and (consp m)
       (eq (car m) 'AP)
       (consp (cadr m))
       (eq (caadr m) 'AP)
       (sortofis (cadr (cadr m)) "c_2Ebool_2E_2F_5C")))

(defun or-p (m)
  (and (consp m)
       (eq (car m) 'AP)
       (consp (cadr m))
       (eq (caadr m) 'AP)
       (sortofis (cadr (cadr m)) "c_2Ebool_2E_5C_2F")))

(defun neg-p (m)
  (and (consp m)
       (eq (car m) 'AP)
       (sortofis (cadr m) "c_2Ebool_2E_7E")))

(defun prop-thf0 (p &optional ctx vctx)
  (setq *p99* p)
  (cond ((neg-p p)
	 (cond ((sortofis (caddr p) "c_2Ebool_2EF")
		(format nil "(~~~~ ($false))"))
	       ((sortofis (caddr p) "c_2Ebool_2ET")
		(format nil "(~~~~ ($true))"))
	       (t
		(format nil "(~~~~ ~d)" (prop-thf0 (caddr p) ctx vctx)))))
	((imp-p p)
	 (format nil "(~d => ~d)"
		 (prop-thf0 (caddr (cadr p)) ctx vctx)
		 (prop-thf0 (caddr p) ctx vctx)))
	((and-p p)
	 (format nil "(~d & ~d)"
		 (prop-thf0 (caddr (cadr p)) ctx vctx)
		 (prop-thf0 (caddr p) ctx vctx)))
	((or-p p)
	 (format nil "(~d | ~d)"
		 (prop-thf0 (caddr (cadr p)) ctx vctx)
		 (prop-thf0 (caddr p) ctx vctx)))
	((equiv-p p)
	 (format nil "(~d <=> ~d)"
		 (prop-thf0 (caddr (cadr p)) ctx vctx)
		 (prop-thf0 (caddr p) ctx vctx)))
	((sortofis p "c_2Ebool_2EF") "$false")
	((sortofis p "c_2Ebool_2ET") "$true")
	((all-p p)
	 (let ((x (cadr (caddr p)))
	       (body (cadddr (caddr p)))
	       (bd (assoc "A_27a" (caddr (cadr p)) :test #'equal)))
	   (unless bd (break))
	   (if (gethash (cdr bd) *specialtypes*)
	       (format nil "( ! [~d:tp__~d] : ~d)" x (gethash (cdr bd) *specialtypes*)
		       (prop-thf0 body (acons x (cdr bd) ctx) (cons (list x (format nil "(inj__~d @ ~d)" (gethash (cdr bd) *specialtypes*) x) (cdr bd) x) vctx)))
	     (format nil "( ! [~d:$i] : ((mem@~d@~d) => ~d))" x x (tp-thf0 (cdr bd))
		     (prop-thf0 body (acons x (cdr bd) ctx) (cons (list x x) vctx))))))
	((ex-p p)
	 (let ((x (cadr (caddr p)))
	       (body (cadddr (caddr p)))
	       (bd (assoc "A_27a" (caddr (cadr p)) :test #'equal)))
	   (unless bd (break))
	   (if (gethash (cdr bd) *specialtypes*)
	       (format nil "(? [~d:tp__~d] : ~d)" x (gethash (cdr bd) *specialtypes*)
		       (prop-thf0 body (acons x (cdr bd) ctx) (cons (list x (format nil "(inj__~d @ ~d)" (gethash (cdr bd) *specialtypes*) x) (cdr bd) x) vctx)))
	     (format nil "(? [~d:$i] : ((mem@~d@~d) & ~d))" x x (tp-thf0 (cdr bd))
		     (prop-thf0 body (acons x (cdr bd) ctx) (cons (list x x) vctx))))))
	((eqn-p p)
	 (let ((a (tm-tp (caddr p) ctx)))
	   (if (gethash a *specialtypes*)
	       (format nil "(~d = ~d)"
		       (stm-thf0 (caddr (cadr p)) a ctx vctx)
		       (stm-thf0 (caddr p) a ctx vctx))
	     (format nil "(~d = ~d)"
		     (tm-thf0 (caddr (cadr p)) ctx vctx)
		     (tm-thf0 (caddr p) ctx vctx)))))
	(t
	 (format nil "(p@~d)" (tm-thf0 p ctx vctx)))))

(setq *outputtff0* nil)
(setq *outputfof* nil)

(defun lambda-lift (tpvars tmvars x a body ctx vctx)
  (let ((fm (gethash (list tpvars tmvars x a body) *lamlift*)))
    (if fm
	(progn
	  (when *currname* (push (car fm) (gethash *currname* *sigdeps*)))
	  (cadr fm))
      (let ((nbody (tm-tff0 body ; might lift some lambdas inside first
			    (acons x a ctx)
			    (if (gethash a *specialtypes*)
				(cons (list x (format nil "inj__~d(~d)" (gethash a *specialtypes*) x) a x) vctx)
			      (cons (list x x) vctx)))))
	(let ((f (format nil "f~d" (incf *lamliftcount*)))
	      (fst t)
	      (args nil))
	  (if (or tpvars tmvars)
	      (let ((sp nil)
		    (pc 0))
		(when *currname* (push f (gethash *currname* *sigdeps*)))
		(format *outputtff0* "tff(lamtp_~d,type,(~d : (" f f)
		(dolist (b tpvars) (format *outputtff0* "~ddel" (if fst "" " * ")) (setq fst nil))
		(dolist (y tmvars)
		  (let ((b (tm-tp y ctx)))
		    (if (gethash b *specialtypes*)
			(format *outputtff0* "~dtp__~d" (if fst "" " * ") (gethash b *specialtypes*))
		      (format *outputtff0* "~d$i" (if fst "" " * ")))
		    (setq fst nil)))
		(format *outputtff0* ") > $i)).~%")
		(dolist (b tpvars) (if sp (setq sp (format nil "~d,~d" sp b)) (setq sp (format nil "~d" b))))
		(dolist (y tmvars) (if sp (setq sp (format nil "~d,~d" sp y)) (setq sp (format nil "~d" y))))
		(setq m (format nil "~d(~d)" f sp))
		(setf (gethash (list tpvars tmvars x a body) *lamlift*) (list f m))
		(format *outputtff0* "tff(lameq_~d,axiom," f)
		(dolist (b tpvars) (format *outputtff0* "( ! [~d:del] : " b) (incf pc))
		(dolist (y tmvars)
		  (let ((b (tm-tp y ctx)))
		    (incf pc)
		    (if (gethash b *specialtypes*)
			(format *outputtff0* "( ! [~d:tp__~d] : " y (gethash b *specialtypes*))
		      (progn
			(incf pc)
			(format *outputtff0* "( ! [~d:$i] : (mem(~d,~d) => " y y (tp-tff0 b))))))
		(if (gethash a *specialtypes*)
		    (format *outputtff0* "( ! [~d:tp__~d] : (ap(~d,inj__~d(~d)) = ~d))" x (gethash a *specialtypes*) m (gethash a *specialtypes*) x nbody)
		  (format *outputtff0* "( ! [~d:$i] : (ap(~d,~d) = ~d))" x m x nbody))
		(dotimes (i pc) (format *outputtff0* ")"))
		(format *outputtff0* ").~%"))
	    (progn
	      (when *currname* (push f (gethash *currname* *sigdeps*)))
	      (format *outputtff0* "tff(lamtp_~d,type,(~d : $i))." f f)
	      (setq m f)
	      (setf (gethash (list tpvars tmvars x a body) *lamlift*) (list f m))
	      (if (gethash a *specialtypes*)
		  (format *outputtff0* "tff(lameq_~d,axiom,( ! [~d:tp__~d] : (ap(~d,inj__~d(~d)) = ~d))).~%" f x (gethash a *specialtypes*) m (gethash a *specialtypes*) x nbody)
		(format *outputtff0* "tff(lameq_~d,axiom,( ! [~d:$i] : (ap(~d,~d) = ~d))).~%" f x m x nbody))))
	  m)))))

(defun stm-tff0 (m a ctx vctx)
  (multiple-value-bind
      (h sp)
      (tm-head-spine m)
    (let ((z (assoc h vctx :test #'equal)))
      (if z
	  (if (and (null sp) (equal (caddr z) a))
	      (cadddr z)
	    (format nil "surj__~d(~d)" (gethash a *specialtypes*) (tm-tff0 m ctx vctx)))
	(if (and (gethash h *foconst*) (= (length sp) (numargstp (gethash h *consttp*))))
	    (stm-tff0-ap (format nil "fo__~d" h) sp (gethash h *consttp*) ctx vctx)
	  (format nil "surj__~d(~d)" (gethash a *specialtypes*) (tm-tff0 m ctx vctx)))))))

(defun stm-tff0-ap (h sp ftp ctx vctx)
  (if (and (consp ftp) (eq (car ftp) 'ARR))
      (if sp
	  (stm-tff0-ap (format nil "~d(~d)" h (stm-tff0 (car sp) (cadr ftp) ctx vctx))
		       (cdr sp)
		       (caddr ftp)
		       ctx vctx)
	(progn (error "impossible 83927")))
    (if sp
	(progn (error "impossible 83928"))
      h)))

(defun tm-tff0 (m &optional ctx vctx)
  (let ((a (tm-tp m ctx)))
    (if (gethash a *specialtypes*)
	(multiple-value-bind
	    (h sp)
	    (tm-head-spine m)
	  (if (and (gethash h *foconst*) (= (length sp) (numargstp (gethash h *consttp*))))
	      (format nil "inj__~d(~d)" (gethash a *specialtypes*) (stm-tff0-ap (format nil "fo__~d" h) sp (gethash h *consttp*) ctx vctx))
	    (tm-tff0-2 m ctx vctx)))
      (tm-tff0-2 m ctx vctx))))
  
(defun tm-tff0-2 (m &optional ctx vctx)
  (if (consp m)
      (cond ((eq (car m) 'AP)
	     (format nil "ap(~d,~d)" (tm-tff0-2 (cadr m) ctx vctx) (tm-tff0 (caddr m) ctx vctx)))
	    ((eq (car m) 'LAMBDA)
	     (let ((tpvars (tm-tpvars m ctx))
		   (tmvars (tm-frees (cadddr m) (acons (cadr m) (caddr m) ctx))))
	       (cond ((equal (cadr m) (cadddr m)) ; identity, just use i
		      (format nil "i(~d)" (tp-tff0 (caddr m))))
		     ((member (cadr m) tmvars :test #'equal) ; only lambda lift if the bd var occurs in the body, otherwise use k
		      (lambda-lift tpvars (remove (cadr m) tmvars :test #'equal) (cadr m) (caddr m) (cadddr m) ctx vctx))
		     (t (format nil "k(~d,~d)" (tp-tff0 (caddr m)) (tm-tff0-2 (cadddr m) ctx vctx)))))) ; bd var does not occur in body
	    ((eq (car m) 'TPSUBST)
	     (let* ((c (cadr m))
		    (theta (caddr m))
		    (tvars (gethash c *consttpvars*))
		    (ral nil))
	       (dolist (v tvars) (let ((a (assoc v theta :test #'equal))) (unless a (break)) (push (cdr a) ral)))
	       (if ral
		   (format nil "~d" (ap-to-tps-tff0 c (reverse ral)))
		 (format nil "~d" c))))
	    (t (break)))
    (let ((z (assoc m vctx :test #'equal)))
      (if z
	  (cadr z)
	(format nil "~d" m)))))

(defun prop-tff0 (p &optional ctx vctx)
  (setq *p99* p)
  (cond ((neg-p p)
	 (cond ((sortofis (caddr p) "c_2Ebool_2EF")
		(format nil "(~~~~ ($false))"))
	       ((sortofis (caddr p) "c_2Ebool_2ET")
		(format nil "(~~~~ ($true))"))
	       (t
		(format nil "(~~~~ ~d)" (prop-tff0 (caddr p) ctx vctx)))))
	((imp-p p)
	 (format nil "(~d => ~d)"
		 (prop-tff0 (caddr (cadr p)) ctx vctx)
		 (prop-tff0 (caddr p) ctx vctx)))
	((and-p p)
	 (format nil "(~d & ~d)"
		 (prop-tff0 (caddr (cadr p)) ctx vctx)
		 (prop-tff0 (caddr p) ctx vctx)))
	((or-p p)
	 (format nil "(~d | ~d)"
		 (prop-tff0 (caddr (cadr p)) ctx vctx)
		 (prop-tff0 (caddr p) ctx vctx)))
	((equiv-p p)
	 (format nil "(~d <=> ~d)"
		 (prop-tff0 (caddr (cadr p)) ctx vctx)
		 (prop-tff0 (caddr p) ctx vctx)))
	((sortofis p "c_2Ebool_2EF") "$false")
	((sortofis p "c_2Ebool_2ET") "$true")
	((all-p p)
	 (let ((x (cadr (caddr p)))
	       (body (cadddr (caddr p)))
	       (bd (assoc "A_27a" (caddr (cadr p)) :test #'equal)))
	   (unless bd (break))
	   (if (gethash (cdr bd) *specialtypes*)
	       (format nil "( ! [~d:tp__~d] : ~d)" x (gethash (cdr bd) *specialtypes*)
		       (prop-tff0 body (acons x (cdr bd) ctx) (cons (list x (format nil "inj__~d(~d)" (gethash (cdr bd) *specialtypes*) x) (cdr bd) x) vctx)))
	     (format nil "( ! [~d:$i] : (mem(~d,~d) => ~d))" x x (tp-tff0 (cdr bd))
		     (prop-tff0 body (acons x (cdr bd) ctx) (cons (list x x) vctx))))))
	((ex-p p)
	 (let ((x (cadr (caddr p)))
	       (body (cadddr (caddr p)))
	       (bd (assoc "A_27a" (caddr (cadr p)) :test #'equal)))
	   (unless bd (break))
	   (if (gethash (cdr bd) *specialtypes*)
	       (format nil "(? [~d:tp__~d] : ~d)" x (gethash (cdr bd) *specialtypes*)
		       (prop-tff0 body (acons x (cdr bd) ctx) (cons (list x (format nil "inj__~d(~d)" (gethash (cdr bd) *specialtypes*) x) (cdr bd) x) vctx)))
	     (format nil "(? [~d:$i] : (mem(~d,~d) & ~d))" x x (tp-tff0 (cdr bd))
		     (prop-tff0 body (acons x (cdr bd) ctx) (cons (list x x) vctx))))))
	((eqn-p p)
	 (let ((a (tm-tp (caddr p) ctx)))
	   (if (gethash a *specialtypes*)
	       (format nil "(~d = ~d)"
		       (stm-tff0 (caddr (cadr p)) a ctx vctx)
		       (stm-tff0 (caddr p) a ctx vctx))
	     (format nil "(~d = ~d)"
		     (tm-tff0 (caddr (cadr p)) ctx vctx)
		     (tm-tff0 (caddr p) ctx vctx)))))
	(t
	 (format nil "p(~d)" (tm-tff0 p ctx vctx)))))

(defun ap-to-tps-fof (s al)
  (if al
      (let ((sp (tp-fof (car al))))
	(dolist (a (cdr al))
	  (setq sp (format nil "~d,~d" sp (tp-fof a))))
	(format nil "~d(~d)" s sp))
    s))

(defun tp-fof (a)
  (if (consp a)
      (if (eq (car a) 'ARR)
	  (format nil "arr(~d,~d)" (tp-fof (cadr a)) (tp-fof (caddr a)))
	(if (stringp (car a))
	    (if (cdr a)
		(ap-to-tps-fof (car a) (cdr a))
	      (car a))
	  (break)))
    (if (eq a 'BOOL)
	"bool"
      (if (eq a 'IND)
	  "ind"
	(if (stringp a)
	    a
	  (break))))))

(defun lambda-lift-fof (tpvars tmvars x a body ctx vctx)
  (let ((fm (gethash (list tpvars tmvars x a body) *lamlift*)))
    (if fm
	(progn
	  (when *currname* (push (car fm) (gethash *currname* *sigdeps*)))
	  (cadr fm))
      (let ((nbody (tm-fof body ; might lift some lambdas inside first
			   (acons x a ctx)
			   (cons (list x x) vctx))))
	(let ((f (format nil "f~d" (incf *lamliftcount*)))
	      (fst t)
	      (args nil))
	  (if (or tpvars tmvars)
	      (let ((sp nil)
		    (pc 0))
		(when *currname* (push f (gethash *currname* *sigdeps*)))
		(dolist (b tpvars) (if sp (setq sp (format nil "~d,~d" sp b)) (setq sp (format nil "~d" b))))
		(dolist (y tmvars) (if sp (setq sp (format nil "~d,~d" sp y)) (setq sp (format nil "~d" y))))
		(setq m (format nil "~d(~d)" f sp))
		(setf (gethash (list tpvars tmvars x a body) *lamlift*) (list f m))
		(format *outputfof* "tff(lameq_~d,axiom," f)
		(dolist (b tpvars) (format *outputfof* "( ! [~d] : " b) (incf pc))
		(dolist (y tmvars)
		  (let ((b (tm-tp y ctx)))
		    (incf pc)
		    (incf pc)
		    (format *outputfof* "( ! [~d] : (mem(~d,~d) => " y y (tp-fof b))))
		(format *outputfof* "( ! [~d] : (ap(~d,~d) = ~d))" x m x nbody)
		(dotimes (i pc) (format *outputfof* ")"))
		(format *outputfof* ").~%"))
	    (progn
	      (when *currname* (push f (gethash *currname* *sigdeps*)))
	      (setq m f)
	      (setf (gethash (list tpvars tmvars x a body) *lamlift*) (list f m))
	      (format *outputfof* "tff(lameq_~d,axiom,( ! [~d] : (ap(~d,~d) = ~d))).~%" f x m x nbody)))
	  m)))))

(defun tm-fof (m &optional ctx vctx)
  (tm-fof-2 m ctx vctx))

(defun tm-fof-2 (m &optional ctx vctx)
  (if (consp m)
      (cond ((eq (car m) 'AP)
	     (format nil "ap(~d,~d)" (tm-fof-2 (cadr m) ctx vctx) (tm-fof (caddr m) ctx vctx)))
	    ((eq (car m) 'LAMBDA)
	     (let ((tpvars (tm-tpvars m ctx))
		   (tmvars (tm-frees (cadddr m) (acons (cadr m) (caddr m) ctx))))
	       (cond ((equal (cadr m) (cadddr m)) ; identity, just use i
		      (format nil "i(~d)" (tp-fof (caddr m))))
		     ((member (cadr m) tmvars :test #'equal) ; only lambda lift if the bd var occurs in the body, otherwise use k
		      (lambda-lift-fof tpvars (remove (cadr m) tmvars :test #'equal) (cadr m) (caddr m) (cadddr m) ctx vctx))
		     (t (format nil "k(~d,~d)" (tp-fof (caddr m)) (tm-fof-2 (cadddr m) ctx vctx)))))) ; bd var does not occur in body
	    ((eq (car m) 'TPSUBST)
	     (let* ((c (cadr m))
		    (theta (caddr m))
		    (tvars (gethash c *consttpvars*))
		    (ral nil))
	       (dolist (v tvars) (let ((a (assoc v theta :test #'equal))) (unless a (break)) (push (cdr a) ral)))
	       (if ral
		   (format nil "~d" (ap-to-tps-fof c (reverse ral)))
		 (format nil "~d" c))))
	    (t (break)))
    (let ((z (assoc m vctx :test #'equal)))
      (if z
	  (cadr z)
	(format nil "~d" m)))))

(defun prop-fof (p &optional ctx vctx (pr 0) (rght t))
  (setq *p99* p)
  (cond ((neg-p p)
	 (cond ((sortofis (caddr p) "c_2Ebool_2EF")
		(format nil "(~~~~ ($false))"))
	       ((sortofis (caddr p) "c_2Ebool_2ET")
		(format nil "(~~~~ ($true))"))
	       (t
		(par pr 55
		     (format nil "~~~~ ~d" (prop-fof (caddr p) ctx vctx 55 t))))))
	((imp-p p)
	 (par pr 75
	      (format nil "~d => ~d"
		      (prop-fof (caddr (cadr p)) ctx vctx 75 nil)
		      (prop-fof (caddr p) ctx vctx 76 t))))
	((and-p p)
	 (par pr 60
	      (format nil "~d & ~d"
		      (prop-fof (caddr (cadr p)) ctx vctx 60 nil)
		      (prop-fof (caddr p) ctx vctx 61 t))))
	((or-p p)
	 (par pr 70
	      (format nil "~d | ~d"
		      (prop-fof (caddr (cadr p)) ctx vctx 70 nil)
		      (prop-fof (caddr p) ctx vctx 71 t))))
	((equiv-p p)
	 (par pr 80
	      (format nil "~d <=> ~d"
		      (prop-fof (caddr (cadr p)) ctx vctx 80 nil)
		      (prop-fof (caddr p) ctx vctx 80 t))))
	((sortofis p "c_2Ebool_2EF") "$false")
	((sortofis p "c_2Ebool_2ET") "$true")
	((all-p p)
	 (let ((x (cadr (caddr p)))
	       (body (cadddr (caddr p)))
	       (bd (assoc "A_27a" (caddr (cadr p)) :test #'equal)))
	   (unless bd (break))
	   (if rght
	       (format nil "! [~d] : ( mem(~d,~d) => ~d )" x x (tp-fof (cdr bd))
		       (prop-fof body (acons x (cdr bd) ctx) (cons (list x x) vctx) 100 t))
	     (format nil "( ! [~d] : ( mem(~d,~d) => ~d ) )" x x (tp-fof (cdr bd))
		     (prop-fof body (acons x (cdr bd) ctx) (cons (list x x) vctx) 100 t)))))
	((ex-p p)
	 (let ((x (cadr (caddr p)))
	       (body (cadddr (caddr p)))
	       (bd (assoc "A_27a" (caddr (cadr p)) :test #'equal)))
	   (unless bd (break))
	   (if rght
	       (format nil "? [~d] : ( mem(~d,~d) & ~d )" x x (tp-fof (cdr bd))
		       (prop-fof body (acons x (cdr bd) ctx) (cons (list x x) vctx) 100 t))
	     (format nil "( ? [~d] : ( mem(~d,~d) & ~d ) )" x x (tp-fof (cdr bd))
		     (prop-fof body (acons x (cdr bd) ctx) (cons (list x x) vctx) 100 t)))))
	((eqn-p p)
	 (let ((a (tm-tp (caddr p) ctx)))
	   (par pr 50
		(format nil "~d = ~d"
			(tm-fof (caddr (cadr p)) ctx vctx)
			(tm-fof (caddr p) ctx vctx)))))
	(t
	 (format nil "p(~d)" (tm-fof p ctx vctx)))))

(defun declare-new-special-types (f)
  (dolist (a *newspecialtypes*)
    (format f "thf(stp_~d,type,(tp__~d : $tType)).~%" (gethash a *specialtypes*) (gethash a *specialtypes*))
    (format f "thf(stp_inj_~d,type,(inj__~d : (tp__~d > $i))).~%" (gethash a *specialtypes*) (gethash a *specialtypes*) (gethash a *specialtypes*))
    (format f "thf(stp_surj_~d,type,(surj__~d : ($i > tp__~d))).~%" (gethash a *specialtypes*) (gethash a *specialtypes*) (gethash a *specialtypes*))
    (format f "thf(stp_inj_surj_~d,axiom,( ! [X:tp__~d] : ((surj__~d @ (inj__~d @ X)) = X))).~%" (gethash a *specialtypes*) (gethash a *specialtypes*) (gethash a *specialtypes*) (gethash a *specialtypes*))
    (format f "thf(stp_inj_mem_~d,axiom,( ! [X:tp__~d] : (mem @ (inj__~d @ X) @ ~d))).~%" (gethash a *specialtypes*) (gethash a *specialtypes*) (gethash a *specialtypes*) (tp-thf0 a))
    (format f "thf(stp_iso_mem_~d,axiom,( ! [X:$i] : ((mem @ X @ ~d) => (X = (inj__~d @ (surj__~d @ X)))))).~%" (gethash a *specialtypes*) (tp-thf0 a) (gethash a *specialtypes*) (gethash a *specialtypes*))
    )
  (setq *newspecialtypes* nil))
    
(defun declare-new-special-types-tff (f)
  (dolist (a *newspecialtypes*)
    (format f "tff(stp_~d,type,(tp__~d : $tType)).~%" (gethash a *specialtypes*) (gethash a *specialtypes*))
    (format f "tff(stp_inj_~d,type,(inj__~d : tp__~d > $i)).~%" (gethash a *specialtypes*) (gethash a *specialtypes*) (gethash a *specialtypes*))
    (format f "tff(stp_surj_~d,type,(surj__~d : $i > tp__~d)).~%" (gethash a *specialtypes*) (gethash a *specialtypes*) (gethash a *specialtypes*))
    (format f "tff(stp_inj_surj_~d,axiom,( ! [X:tp__~d] : (surj__~d(inj__~d(X)) = X))).~%" (gethash a *specialtypes*) (gethash a *specialtypes*) (gethash a *specialtypes*) (gethash a *specialtypes*))
    (format f "tff(stp_inj_mem_~d,axiom,( ! [X:tp__~d] : (mem(inj__~d(X),~d)))).~%" (gethash a *specialtypes*) (gethash a *specialtypes*) (gethash a *specialtypes*) (tp-tff0 a))
    (format f "tff(stp_iso_mem_~d,axiom,( ! [X:$i] : (mem(X,~d) => (X = inj__~d(surj__~d(X)))))).~%" (gethash a *specialtypes*) (tp-tff0 a) (gethash a *specialtypes*) (gethash a *specialtypes*))
    )
  (setq *newspecialtypes* nil))
    
(defun process-type-decl (name n)
  (unless (numberp n) (format t "ERROR: ~d has non number arity ~d" name n) (break))
  (when (gethash name *typearity*) (format t "ERROR: ~d is redeclared as a type constructor" name) (break))
  (setf (gethash name *typearity*) n)
  (when (and *outputthf0* (not (member name '("ty_2Emin_2Ebool" "ty_2Emin_2Efun" "ty_2Emin_2Eind") :test #'equal)))
    (declare-new-special-types *outputthf0*)
    (format *outputthf0* "thf(tp_~d,type,( ~d:" name name)
    (dotimes (i n) (format *outputthf0* " del >"))
    (format *outputthf0* "del")
    (format *outputthf0* " )).~%"))
;    (let ((ral nil))
;      (format *outputthf0* "thf(ne_~d,axiom," name)
;      (dotimes (i n) (format *outputthf0* "( ! [A~d:$i] : ( ( ne @ A~d) => " i i) (push (format nil "A~d" i) ral))
;      (if (> n 0)
;	  (format *outputthf0* "(ne@(~d))" (ap-to-tps-thf0 name (reverse ral)))
;	(format *outputthf0* "(ne@~d)" name))
;      (dotimes (i n) (format *outputthf0* "))"))
;      (format *outputthf0* ").~%"))
;    )
  (when (and *outputtff0* (not (member name '("ty_2Emin_2Ebool" "ty_2Emin_2Efun" "ty_2Emin_2Eind") :test #'equal)))
    (declare-new-special-types-tff *outputtff0*)
    (if (= n 0)
	(progn
	  (format *outputtff0* "tff(tp_~d,type,( ~d: del )).~%" name name))
      (if (= n 1)
	  (progn
	    (format *outputtff0* "tff(tp_~d,type,( ~d: del > del )).~%" name name))
	(progn
	  (format *outputtff0* "tff(tp_~d,type,( ~d: ( del" name name)
	  (dotimes (i (- n 1)) (format *outputtff0* " * del"))
	  (format *outputtff0* " ) > del )).~%")
	  ))))
  (when (and *outputfof* (not (member name '("ty_2Emin_2Ebool" "ty_2Emin_2Efun" "ty_2Emin_2Eind") :test #'equal)))
    (if (= n 0)
	(let ((znm (format nil "ne_~d" name))
	      (decl (format nil "fof(ne_~d,axiom,( ne(~d) ))." name name)))
	  (when (and (gethash (cons znm "axiom") *oh*) (not (almostequal (gethash (cons znm "axiom") *oh*) decl)))
	    (setq *znm* znm *decl* decl)
	    (break))
	  (format *outputfof* "~d~%" decl))
      (progn
	(let ((ral nil)
	      (znm (format nil "ne_~d" name))
	      (decl (format nil "fof(ne_~d,axiom," name)))
	  (dotimes (i n) (setq decl (format nil "~d( ! [A~d] : ( ne(A~d) => " decl i i)) (push (format nil "A~d" i) ral))
	  (setq decl (format nil "~dne(~d)" decl (ap-to-tps-fof name (reverse ral))))
	  (dotimes (i n) (setq decl (format nil "~d ) )" decl)))
	  (setq decl (format nil "~d)." decl))
	  (when (and (gethash (cons znm "axiom") *oh*) (not (almostequal (gethash (cons znm "axiom") *oh*) decl)))
	    (setq *znm* znm *decl* decl)
	    (break))
	  (format *outputfof* "~d~%" decl))))))

(defun fotp-thf0 (a)
  (if (and (consp a) (eq (car a) 'ARR))
      (format nil "(tp__~d > ~d)" (gethash (cadr a) *specialtypes*) (fotp-thf0 (caddr a)))
    (format nil "tp__~d" (gethash a *specialtypes*))))

(defun fotp-tff0 (a &optional intp)
  (if (and (consp a) (eq (car a) 'ARR))
      (if intp
	  (fotp-tff0 (caddr a) (format nil "~d * tp__~d" intp (gethash (cadr a) *specialtypes*)))
	(fotp-tff0 (caddr a) (format nil "tp__~d" (gethash (cadr a) *specialtypes*))))
    (if intp
	(format nil "(~d) > tp__~d" intp (gethash a *specialtypes*))
      (format nil "tp__~d" (gethash a *specialtypes*)))))

(defun foeq-thf0 (l r a &optional (i 0))
  (if (and (consp a) (eq (car a) 'ARR))
      (format nil "( ! [X~d:tp__~d] : ~d)" i (gethash (cadr a) *specialtypes*)
	      (foeq-thf0 (format nil "(~d @ X~d)" l i)
			 (format nil "(ap @ ~d @ (inj__~d @ X~d))" r (gethash (cadr a) *specialtypes*) i)
			 (caddr a)
			 (1+ i)))
    (format nil "((inj__~d @ ~d) = ~d)" (gethash a *specialtypes*) l r)))

(defun foeq-tff0 (l largs r a &optional (i 0))
  (if (and (consp a) (eq (car a) 'ARR))
      (format nil "( ! [X~d:tp__~d] : ~d)" i (gethash (cadr a) *specialtypes*)
	      (foeq-tff0 l
			 (if largs (format nil "~d,X~d" largs i) (format nil "X~d" i))
			 (format nil "ap(~d,inj__~d(X~d))" r (gethash (cadr a) *specialtypes*) i)
			 (caddr a)
			 (1+ i)))
    (if largs
	(format nil "(inj__~d(~d(~d)) = ~d)" (gethash a *specialtypes*) l largs r)
      (format nil "(inj__~d(~d) = ~d)" (gethash a *specialtypes*) l r))))

(defun process-const-decl (name a)
  (setq *currname* name)
  (when (gethash name *consttp*) (format t "ERROR: ~d is redeclared as a constant" name) (break))
  (multiple-value-bind
   (atp atpvars)
   (transl-ptp a)
   (setf (gethash name *consttpvars*) atpvars)
   (setf (gethash name *consttp*) atp)
   (when (and *outputthf0* (not (member name '("c_2Ebool_2E_20___20fakeconst4_2Ecase_2CS10_2Ecase_20magic_2C7_2Edefault"
					       "c_2Ebool_2E_20___20fakeconst5_2Earrow_2CS10_2Ecase_20magic_2C7_2Edefault"
					       "c_2Ebool_2E_20___20fakeconst5_2Esplit_2CS10_2Ecase_20magic_2C7_2Edefault")
					:test #'equal)))
     (declare-new-special-types *outputthf0*)
     (format *outputthf0* "thf(tp_~d,type,(~d:" name name)
     (dolist (v atpvars) (format *outputthf0* "(del>"))
     (format *outputthf0* "$i")
     (dolist (v atpvars) (format *outputthf0* ")"))
     (format *outputthf0* ")).~%")
     (format *outputthf0* "thf(mem_~d,axiom," name name)
     (dolist (v atpvars) (format *outputthf0* "( ! [~d:del] : " v))
     (if atpvars
	 (format *outputthf0* "(mem@(~d)@~d)" (ap-to-tps-thf0 name atpvars) (tp-thf0 atp))
       (format *outputthf0* "(mem@~d@~d)" name (tp-thf0 atp)))
     (dolist (v atpvars) (format *outputthf0* ")"))
     (format *outputthf0* ").~%")
     (when (foishtp-p atp) ; can give a fo rep of this constant
       (setf (gethash name *foconst*) t)
       (format *outputthf0* "thf(stp_fo_~d,type,(fo__~d:~d)).~%" name name (fotp-thf0 atp))
       (format *outputthf0* "thf(stp_eq_fo_~d,axiom,~d).~%" name (foeq-thf0 (format nil "fo__~d" name) (format nil "~d" name) atp)))
					; for logical constants give the correspondence between the internal and external versions
     (cond ((equal name "c_2Emin_2E_3D") ; equality (and equivalence via prop extensionality in the preface)
	    (format *outputthf0* "thf(ax_eq_p,axiom,( ! [A:del] : ( ! [X:$i] : ((mem@X@A) => ( ! [Y:$i] : ((mem@Y@A) => ((p@(ap@(ap@(c_2Emin_2E_3D@A)@X)@Y)) <=> (X = Y)))))))).~%")
	    )
	   ((equal name "c_2Ebool_2E_21") ; forall
	    (format *outputthf0* "thf(ax_all_p,axiom,( ! [A:del] : ( ! [Q:$i] : ((mem@Q@(arr@A@bool)) => ((p@(ap@(c_2Ebool_2E_21@A)@Q)) <=> ( ! [X:$i] : ((mem@X@A) => (p@(ap@Q@X))))))))).~%")
	    )
	   ((equal name "c_2Ebool_2E_3F") ; exists
	    (format *outputthf0* "thf(ax_ex_p,axiom,( ! [A:del] : ( ! [Q:$i] : ((mem@Q@(arr@A@bool)) => ((p@(ap@(c_2Ebool_2E_3F@A)@Q)) <=> (? [X:$i] : ((mem@X@A) & (p@(ap@Q@X))))))))).~%")
	    )
	   ((equal name "c_2Ebool_2E_2F_5C") ; and
	    (format *outputthf0* "thf(ax_and_p,axiom,( ! [Q:$i] : ((mem@Q@bool) => ( ! [R:$i] : ((mem@R@bool) => ((p@(ap@(ap@c_2Ebool_2E_2F_5C@Q)@R)) <=> ((p@Q) & (p@R)))))))).~%")
	    )
	   ((equal name "c_2Ebool_2E_5C_2F") ; or
	    (format *outputthf0* "thf(ax_or_p,axiom,( ! [Q:$i] : ((mem@Q@bool) => ( ! [R:$i] : ((mem@R@bool) => ((p@(ap@(ap@c_2Ebool_2E_5C_2F@Q)@R)) <=> ((p@Q) | (p@R)))))))).~%")
	    )
	   ((equal name "c_2Emin_2E_3D_3D_3E") ; implies
	    (format *outputthf0* "thf(ax_imp_p,axiom,( ! [Q:$i] : ((mem@Q@bool) => ( ! [R:$i] : ((mem@R@bool) => ((p@(ap@(ap@c_2Emin_2E_3D_3D_3E@Q)@R)) <=> ((p@Q) => (p@R)))))))).~%")
	    )
	   ((equal name "c_2Ebool_2E_7E") ; neg
	    (format *outputthf0* "thf(ax_neg_p,axiom,( ! [Q:$i] : ((mem@Q@bool) => ((p@(ap@c_2Ebool_2E_7E@Q)) <=> (~~ (p@Q)))))).~%")
	    )
	   ((equal name "c_2Ebool_2EF") ; false
	    (format *outputthf0* "thf(ax_false_p,axiom,(~~ (p@c_2Ebool_2EF))).~%")
	    )
	   ((equal name "c_2Ebool_2ET") ; true
	    (format *outputthf0* "thf(ax_true_p,axiom,(p@c_2Ebool_2ET)).~%")
	    )
	   (t nil)))
   (when (and *outputtff0* (not (member name '("c_2Ebool_2E_20___20fakeconst4_2Ecase_2CS10_2Ecase_20magic_2C7_2Edefault"
					       "c_2Ebool_2E_20___20fakeconst5_2Earrow_2CS10_2Ecase_20magic_2C7_2Edefault"
					       "c_2Ebool_2E_20___20fakeconst5_2Esplit_2CS10_2Ecase_20magic_2C7_2Edefault")
					:test #'equal)))
     (declare-new-special-types-tff *outputtff0*)
     (format *outputtff0* "tff(tp_~d,type,(~d:" name name)
     (if atpvars
	 (if (cdr atpvars)
	     (progn
	       (format *outputtff0* "(del")
	       (dolist (v (cdr atpvars)) (format *outputtff0* " * del"))
	       (format *outputtff0* ") > $i)).~%"))
	   (format *outputtff0* "del > $i)).~%"))
       (format *outputtff0* "$i)).~%"))
     (format *outputtff0* "tff(mem_~d,axiom," name name)
     (dolist (v atpvars) (format *outputtff0* "( ! [~d:del] : " v v))
     (if atpvars
	 (format *outputtff0* "mem(~d,~d)" (ap-to-tps-tff0 name atpvars) (tp-tff0 atp))
       (format *outputtff0* "mem(~d,~d)" name (tp-tff0 atp)))
     (dolist (v atpvars) (format *outputtff0* ")"))
     (format *outputtff0* ").~%")
     (when (foishtp-p atp) ; can give a fo rep of this constant
       (setf (gethash name *foconst*) t)
       (format *outputtff0* "tff(stp_fo_~d,type,(fo__~d:~d)).~%" name name (fotp-tff0 atp))
       (format *outputtff0* "tff(stp_eq_fo_~d,axiom,~d).~%" name (foeq-tff0 (format nil "fo__~d" name) nil (format nil "~d" name) atp)))
					; for logical constants give the correspondence between the internal and external versions
     (cond ((equal name "c_2Emin_2E_3D") ; equality (and equivalence via prop extensionality in the preface)
	    (format *outputtff0* "tff(ax_eq_p,axiom,( ! [A:del] : ( ! [X:$i] : (mem(X,A) => ( ! [Y:$i] : (mem(Y,A) => (p(ap(ap(c_2Emin_2E_3D(A),X),Y)) <=> (X = Y)))))))).~%")
	    )
	   ((equal name "c_2Ebool_2E_21") ; forall
	    (format *outputtff0* "tff(ax_all_p,axiom,( ! [A:del] : ( ! [Q:$i] : (mem(Q,arr(A,bool)) => (p(ap(c_2Ebool_2E_21(A),Q)) <=> ( ! [X:$i] : (mem(X,A) => p(ap(Q,X))))))))).~%")
	    )
	   ((equal name "c_2Ebool_2E_3F") ; exists
	    (format *outputtff0* "tff(ax_ex_p,axiom,( ! [A:del] : ( ! [Q:$i] : (mem(Q,arr(A,bool)) => (p(ap(c_2Ebool_2E_3F(A),Q)) <=> (? [X:$i] : (mem(X,A) & p(ap(Q,X))))))))).~%")
	    )
	   ((equal name "c_2Ebool_2E_2F_5C") ; and
	    (format *outputtff0* "tff(ax_and_p,axiom,( ! [Q:$i] : (mem(Q,bool) => ( ! [R:$i] : (mem(R,bool) => (p(ap(ap(c_2Ebool_2E_2F_5C,Q),R)) <=> (p(Q) & p(R)))))))).~%")
	    )
	   ((equal name "c_2Ebool_2E_5C_2F") ; or
	    (format *outputtff0* "tff(ax_or_p,axiom,( ! [Q:$i] : (mem(Q,bool) => ( ! [R:$i] : (mem(R,bool) => (p(ap(ap(c_2Ebool_2E_5C_2F,Q),R)) <=> (p(Q) | p(R)))))))).~%")
	    )
	   ((equal name "c_2Emin_2E_3D_3D_3E") ; implies
	    (format *outputtff0* "tff(ax_imp_p,axiom,( ! [Q:$i] : (mem(Q,bool) => ( ! [R:$i] : (mem(R,bool) => (p(ap(ap(c_2Emin_2E_3D_3D_3E,Q),R)) <=> (p(Q) => p(R)))))))).~%")
	    )
	   ((equal name "c_2Ebool_2E_7E") ; neg
	    (format *outputtff0* "tff(ax_neg_p,axiom,( ! [Q:$i] : (mem(Q,bool) => (p(ap(c_2Ebool_2E_7E,Q)) <=> (~~ p(Q)))))).~%")
	    )
	   ((equal name "c_2Ebool_2EF") ; false
	    (format *outputtff0* "tff(ax_false_p,axiom,(~~ p(c_2Ebool_2EF))).~%")
	    )
	   ((equal name "c_2Ebool_2ET") ; true
	    (format *outputtff0* "tff(ax_true_p,axiom,p(c_2Ebool_2ET)).~%")
	    )
	   (t nil)))
   (when (and *outputfof* (not (member name '("c_2Ebool_2E_20___20fakeconst4_2Ecase_2CS10_2Ecase_20magic_2C7_2Edefault"
					       "c_2Ebool_2E_20___20fakeconst5_2Earrow_2CS10_2Ecase_20magic_2C7_2Edefault"
					       "c_2Ebool_2E_20___20fakeconst5_2Esplit_2CS10_2Ecase_20magic_2C7_2Edefault")
				       :test #'equal)))
     (let ((znm (format nil "mem_~d" name))
	   (decl (format nil "fof(mem_~d,axiom,(" name)))
       (dolist (v atpvars) (setq decl (format nil "~d ! [~d] : ( ne(~d) =>" decl v v)))
       (if atpvars
	   (setq decl (format nil "~d mem(~d,~d)" decl (ap-to-tps-fof name atpvars) (tp-fof atp)))
	 (setq decl (format nil "~d mem(~d,~d)" decl name (tp-fof atp))))
       (dolist (v atpvars) (setq decl (format nil "~d )" decl)))
       (setq decl (format nil "~d ))." decl))
       (when (and (gethash (cons znm "axiom") *oh*) (not (almostequal (gethash (cons znm "axiom") *oh*) decl)))
	 (setq *znm* znm *decl* decl)
	 (break))
       (format *outputfof* "~d~%" decl))
       

					; for logical constants give the correspondence between the internal and external versions
     (cond ((equal name "c_2Emin_2E_3D") ; equality (and equivalence via prop extensionality in the preface)
	    (format *outputfof* "fof(ax_eq_p,axiom,( ! [A] : ( ne(A) => ! [X] : ( mem(X,A) => ! [Y] : ( mem(Y,A) => ( p(ap(ap(c_2Emin_2E_3D(A),X),Y)) <=> X = Y ) ) ) ) )).~%")
	    )
	   ((equal name "c_2Ebool_2E_21") ; forall
	    (format *outputfof* "fof(ax_all_p,axiom,( ! [A] : ( ne(A) => ! [Q] : ( mem(Q,arr(A,bool)) => ( p(ap(c_2Ebool_2E_21(A),Q)) <=> ! [X] : ( mem(X,A) => p(ap(Q,X)) ) ) ) ) )).~%")
	    )
	   ((equal name "c_2Ebool_2E_3F") ; exists
	    (format *outputfof* "fof(ax_ex_p,axiom,( ! [A] : ( ne(A) => ! [Q] : ( mem(Q,arr(A,bool)) => ( p(ap(c_2Ebool_2E_3F(A),Q)) <=> ? [X] : ( mem(X,A) & p(ap(Q,X)) ) ) ) ) )).~%")
	    )
	   ((equal name "c_2Ebool_2E_2F_5C") ; and
	    (format *outputfof* "fof(ax_and_p,axiom,( ! [Q] : ( mem(Q,bool) => ! [R] : ( mem(R,bool) => ( p(ap(ap(c_2Ebool_2E_2F_5C,Q),R)) <=> ( p(Q) & p(R) ) ) ) ) )).~%")
	    )
	   ((equal name "c_2Ebool_2E_5C_2F") ; or
	    (format *outputfof* "fof(ax_or_p,axiom,( ! [Q] : ( mem(Q,bool) => ! [R] : ( mem(R,bool) => ( p(ap(ap(c_2Ebool_2E_5C_2F,Q),R)) <=> ( p(Q) | p(R) ) ) ) ) )).~%")
	    )
	   ((equal name "c_2Emin_2E_3D_3D_3E") ; implies
	    (format *outputfof* "fof(ax_imp_p,axiom,( ! [Q] : ( mem(Q,bool) => ! [R] : ( mem(R,bool) => ( p(ap(ap(c_2Emin_2E_3D_3D_3E,Q),R)) <=> ( p(Q) => p(R) ) ) ) ) )).~%")
	    )
	   ((equal name "c_2Ebool_2E_7E") ; neg
	    (format *outputfof* "fof(ax_neg_p,axiom,( ! [Q] : ( mem(Q,bool) => ( p(ap(c_2Ebool_2E_7E,Q)) <=> ~~ p(Q) ) ) )).~%")
	    )
	   ((equal name "c_2Ebool_2EF") ; false
	    (format *outputfof* "fof(ax_false_p,axiom,( ~~ p(c_2Ebool_2EF) )).~%")
	    )
	   ((equal name "c_2Ebool_2ET") ; true
	    (format *outputfof* "fof(ax_true_p,axiom,( p(c_2Ebool_2ET) )).~%")
	    )
	   (t nil)))))

(defun process-axiom (name p)
  (setq *currname* name)
  (when (gethash name *prop*) (format t "ERROR: ~d is redeclared as a prop" name) (break))
  (multiple-value-bind
   (pr prtpvars)
   (transl-prop p)
   (setf (gethash name *proptpvars*) prtpvars)
   (setf (gethash name *prop*) pr)
   (unless (equal (tm-tp pr) 'BOOL) (error (format nil "non bool type for axiom ~d" name)))
   (when *outputthf0*
;     (when (equal name "thm_2Ebool_2EFORALL__DEF") (setq *p* p *pr* pr) (break))
     (declare-new-special-types *outputthf0*)
     (format *outputthf0* "thf(ax_~d,axiom," name)
     (dolist (v prtpvars) (format *outputthf0* "( ! [~d:del]: " v))
     (format *outputthf0* (prop-thf0 pr))
     (dolist (v prtpvars) (format *outputthf0* ")"))
     (format *outputthf0* ").~%"))
   (when *outputtff0*
;     (when (equal name "thm_2Ebool_2EFORALL__DEF") (setq *p* p *pr* pr) (break))
     (declare-new-special-types-tff *outputtff0*)
     (let ((prstr (prop-tff0 pr))
	   (znm (format nil "ax_~d" name))
	   (decl (format nil "tff(ax_~d,axiom," name)))
       (dolist (v prtpvars) (setq decl (format nil "~d( ! [~d:del]: " decl v v)))
       (setq decl (format nil "~d~d" decl prstr))
       (dolist (v prtpvars) (setq decl (format nil "~d)" decl)))
       (setq decl (format nil "~d)." decl))
       (when (and (gethash (cons znm "axiom") *oh*) (not (almostequal (gethash (cons znm "axiom") *oh*) decl)))
	 (setq *znm* znm *decl* decl)
	 (break))
       (format *outputtff0* "~d~%" decl)
       ))
   (when *outputfof*
;     (when (equal name "thm_2Ebool_2EFORALL__DEF") (setq *p* p *pr* pr) (break))
     (let ((prstr (prop-fof pr nil nil (if prtpvars 76 0)))
	   (znm (format nil "ax_~d" name))
	   (decl (format nil "fof(ax_~d,axiom," name)))
       (when prtpvars (setq decl (format nil "~d(" decl)))
       (dolist (v prtpvars) (setq decl (format nil "~d ! [~d] : ( ne(~d) =>" decl v v)))
       (setq decl (format nil "~d ~d" decl prstr))
       (dolist (v prtpvars) (setq decl (format nil "~d )" decl)))
       (when prtpvars (setq decl (format nil "~d )" decl)))
       (setq decl (format nil "~d)." decl))
       (when (and (gethash (cons znm "axiom") *oh*) (not (almostequal (gethash (cons znm "axiom") *oh*) decl)))
	 (setq *znm* znm *decl* decl)
	 (break))
       (format *outputfof* "~d~%" decl)
       ))))

(defun process-conj (name p)
  (setq *currname* name)
  (when (gethash name *prop*) (format t "ERROR: ~d is redeclared as a prop" name) (break))
  (multiple-value-bind
   (pr prtpvars)
   (transl-prop p)
   (setf (gethash name *proptpvars*) prtpvars)
   (setf (gethash name *prop*) pr)
   (unless (equal (tm-tp pr) 'BOOL) (error (format nil "non bool type for conj ~d" name)))
   (when *outputthf0*
;     (when (equal name "thm_2Ebool_2EF__IMP") (setq *p* p *pr* pr) (break))
     (declare-new-special-types *outputthf0*)
     (format *outputthf0* "thf(conj_~d,lemma," name)
     (dolist (v prtpvars) (format *outputthf0* "( ! [~d:del]: " v))
     (format *outputthf0* (prop-thf0 pr))
     (dolist (v prtpvars) (format *outputthf0* ")"))
     (format *outputthf0* ").~%"))
   (when *outputtff0*
;     (when (equal name "thm_2Ebool_2EF__IMP") (setq *p* p *pr* pr) (break))
     (declare-new-special-types-tff *outputtff0*)
     (let ((prstr (prop-tff0 pr))
	   (znm (format nil "conj_~d" name))
	   (decl (format nil "tff(conj_~d,lemma,(" name)))
       (dolist (v prtpvars) (setq decl (format nil "~d( ! [~d:del]: " decl v v)))
       (setq decl (format nil "~d~d" decl prstr))
       (dolist (v prtpvars) (setq decl (format nil "~d)" decl)))
       (setq decl (format nil "~d))." decl))
       (when (and (gethash (cons znm "conjecture") *oh*) (not (almostequal (gethash (cons znm "conjecture") *oh*) decl)))
	 (setq *znm* znm *decl* decl)
	 (break))
       (format *outputtff0* "~d~%" decl)))
   (when *outputfof*
;     (when (equal name "thm_2Ebool_2EF__IMP") (setq *p* p *pr* pr) (break))
     (let ((prstr (prop-fof pr))
       	   (znm (format nil "conj_~d" name))
	   (decl (format nil "fof(conj_~d,lemma,(" name)))
       (dolist (v prtpvars) (setq decl (format nil "~d ! [~d]: ( ne(~d) => " decl v v)))
       (setq decl (format nil "~d~d" decl prstr))
       (dolist (v prtpvars) (setq decl (format nil "~d)" decl)))
       (setq decl (format nil "~d))." decl))
       (when (and (gethash (cons znm "conjecture") *oh*) (not (almostequal (gethash (cons znm "conjecture") *oh*) decl)))
	 (setq *znm* znm *decl* decl)
	 (break))
       (format *outputfof* "~d~%" decl)))))

(defun process-conj-form (name p)
  (setq *currname* name)
  (when (gethash name *prop*) (format t "ERROR: ~d is redeclared as a prop" name) (break))
  (multiple-value-bind
   (pr prtpvars)
   (transl-prop p)
   (setf (gethash name *proptpvars*) prtpvars)
   (setf (gethash name *prop*) pr)
   (unless (equal (tm-tp pr) 'BOOL) (error (format nil "non bool type for conj ~d" name)))
   (if *outputthf0*
					;     (when (equal name "thm_2Ebool_2EF__IMP") (setq *p* p *pr* pr) (break))
       (let ((rstr ""))
	 (declare-new-special-types *outputthf0*)
	 (dolist (v prtpvars) (setq rstr (format nil "~d( ! [~d:del]: " rstr v)))
	 (setq rstr (format nil "~d~d" rstr (prop-thf0 pr)))
	 (dolist (v prtpvars) (setq rstr (format nil "~d)" rstr)))
	 rstr)
     (if *outputtff0*
					;     (when (equal name "thm_2Ebool_2EF__IMP") (setq *p* p *pr* pr) (break))
	 (progn
	   (declare-new-special-types-tff *outputtff0*)
	   (let ((prstr (prop-tff0 pr))
		 (znm (format nil "conj_~d" name))
		 (decl (format nil "(")))
	     (dolist (v prtpvars) (setq decl (format nil "~d( ! [~d:del]: " decl v v)))
	     (setq decl (format nil "~d~d" decl prstr))
	     (dolist (v prtpvars) (setq decl (format nil "~d)" decl)))
	     (setq decl (format nil "~d)" decl))
	     decl))
       (if *outputfof*
;     (when (equal name "thm_2Ebool_2EF__IMP") (setq *p* p *pr* pr) (break))
	   (let ((prstr (prop-fof pr))
		 (znm (format nil "conj_~d" name))
		 (decl (format nil "(" name)))
	     (dolist (v prtpvars) (setq decl (format nil "~d ! [~d]: ( ne(~d) => " decl v v)))
	     (setq decl (format nil "~d~d" decl prstr))
	     (dolist (v prtpvars) (setq decl (format nil "~d)" decl)))
	     (setq decl (format nil "~d)" decl))
	     decl)
	 nil)))))

(defun process-theory (th &optional (subdir ""))
  (setq *f* (open (format nil "~d~d" subdir th) :direction :input))
  (loop while (setq l (read *f* nil nil)) do
	(setq *l* l)
    (if (consp l)
        (case (car l)
	  (TYPE_DEFINITION (process-type-decl (cadr l) (caddr l)))
	  (CONSTANT_DEFINITION (process-const-decl (cadr l) (caddr l)))
	  (AXIOM (process-axiom (cadr l) (caddr l)))
	  (CONJECTURE (process-conj (cadr l) (caddr l)))
	  (t (break)))
	(break)))
  (close *f*))

(defun set-theories ()
  (setq theories nil)
  (let ((f (open "casc_sexpr_hol4/theories" :direction :input))
	(l nil))
    (loop while (setq l (read-line f nil nil)) do
	  (when (> (length l) 0) (push l theories)))
    (close f)
    (setq theories (reverse theories))))

(defun first-nonempty-line (f) (loop while (and (setq l (read-line f nil nil)) (equal l "")) do (numberp 0)) l)
(defun skip-to-empty-line (f) (loop while (and (setq l (read-line f nil nil)) (not (equal l ""))) do (numberp 0)))

(defun set-conjdeps ()
  (setq *conjdeps* nil)
  (let (f itm)
    (dolist (th theories)
      (setq f (open (format nil "casc_sexpr_hol4/~d.dep" th) :direction :input))
      (loop while (setq itm (first-nonempty-line f)) do
	    (when (equal (read-line f nil nil) "conjecture")
	      (when (equal (read-line f nil nil) "intact")
		(push (list th (read-from-string itm) (read-from-string (format nil "(~d)~%" (read-line f nil nil)))) *conjdeps*)))
	    (skip-to-empty-line f))
      (close f))))

(defun output-sigdeps (f sigdeps done)
  (if sigdeps
      (if (member (car sigdeps) done :test #'equal)
          (output-sigdeps f (cdr sigdeps) done)
       (let ((done (output-sigdeps f (remove (car sigdeps) (gethash (car sigdeps) *sigdeps*) :test #'equal) done)))
          (dolist (l (reverse (gethash (car sigdeps) *assumelines*))) (format f "~d~%" l))
          (output-sigdeps f (cdr sigdeps) (cons (car sigdeps) done))))
    done))

(setq *assumelines* (make-hash-table :test #'equal))
(setq *conjline* (make-hash-table :test #'equal))
(setq *allassumes* nil)
(setq *conjchainy* (make-hash-table :test #'equal))

(defun set-tables (f prefix)
  (setq f (open f :direction :input))
  (setq *assumelines* (make-hash-table :test #'equal))
  (setq *conjline* (make-hash-table :test #'equal))
  (setq *allassumes* nil)
  (setq *conjchainy* (make-hash-table :test #'equal))
  (loop while (setq l (read-line f nil nil)) do
	(setq p1 (position #\( l))
	(setq c1 (position #\, l))
	(when (and p1 c1)
	  (setq c2 (position #\, (subseq l (1+ c1))))
	  (when c2
	    (setq name (subseq l (1+ p1) c1))
	    (setq role (subseq l (1+ c1) (+ 1 c1 c2)))
	    (cond ((and (equal role "type") (> (length name) 3) (equal (subseq name 0 3) "tp_"))
		   (push l (gethash (subseq name 3) *assumelines*))
		   (push l *allassumes*))
		  ((equal name "ax_eq_p")
		   (push l (gethash "c_2Emin_2E_3D" *assumelines*))
		   (push l *allassumes*))
		  ((equal name "ax_all_p")
		   (push l (gethash "c_2Ebool_2E_21" *assumelines*))
		   (push l *allassumes*))
		  ((equal name "ax_ex_p")
		   (push l (gethash "c_2Ebool_2E_3F" *assumelines*))
		   (push l *allassumes*))
		  ((equal name "ax_and_p")
		   (push l (gethash "c_2Ebool_2E_2F_5C" *assumelines*))
		   (push l *allassumes*))
		  ((equal name "ax_or_p")
		   (push l (gethash "c_2Ebool_2E_5C_2F" *assumelines*))
		   (push l *allassumes*))
		  ((equal name "ax_imp_p")
		   (push l (gethash "c_2Emin_2E_3D_3D_3E" *assumelines*))
		   (push l *allassumes*))
		  ((equal name "ax_neg_p")
		   (push l (gethash "c_2Ebool_2E_7E" *assumelines*))
		   (push l *allassumes*))
		  ((equal name "ax_false_p")
		   (push l (gethash "c_2Ebool_2EF" *assumelines*))
		   (push l *allassumes*))
		  ((equal name "ax_true_p")
		   (push l (gethash "c_2Ebool_2ET" *assumelines*))
		   (push l *allassumes*))
		  ((and (equal role "axiom") (> (length name) 3) (equal (subseq name 0 3) "ne_"))
		   (push l (gethash (subseq name 3) *assumelines*))
		   (push l *allassumes*))
		  ((and (equal role "axiom") (> (length name) 4) (equal (subseq name 0 4) "mem_"))
		   (push l (gethash (subseq name 4) *assumelines*))
		   (push l *allassumes*))
		  ((and (equal role "axiom") (> (length name) 3) (equal (subseq name 0 3) "ax_"))
		   (push l (gethash (subseq name 3) *assumelines*))
		   (push l *allassumes*))
		  ((and (equal role "lemma") (> (length name) 5) (equal (subseq name 0 5) "conj_"))
		   (push l (gethash (subseq name 5) *assumelines*))
		   (setf (gethash (subseq name 5) *conjline*) (format nil "~d(~d,conjecture,~d" prefix name (subseq l (+ 2 c1 c2))))
		   (setf (gethash (subseq name 5) *conjchainy*) (reverse *allassumes*))
		   (push l *allassumes*))
		  ((and (equal role "axiom") (> (length name) 12) (equal (subseq name 0 12) "stp_iso_mem_"))
		   (push l (gethash (subseq name 12) *assumelines*))
		   (push l *allassumes*))
		  ((and (equal role "axiom") (> (length name) 12) (equal (subseq name 0 12) "stp_inj_mem_"))
		   (push l (gethash (subseq name 12) *assumelines*))
		   (push l *allassumes*))
		  ((and (equal role "axiom") (> (length name) 13) (equal (subseq name 0 13) "stp_inj_surj_"))
		   (push l (gethash (subseq name 13) *assumelines*))
		   (push l *allassumes*))
		  ((and (equal role "type") (> (length name) 8) (equal (subseq name 0 8) "stp_inj_"))
		   (push l (gethash (subseq name 8) *assumelines*))
		   (push l *allassumes*))
		  ((and (equal role "type") (> (length name) 9) (equal (subseq name 0 9) "stp_surj_"))
		   (push l (gethash (subseq name 9) *assumelines*))
		   (push l *allassumes*))
		  ((and (equal role "type") (> (length name) 7) (equal (subseq name 0 7) "stp_fo_"))
		   (push l (gethash (subseq name 7) *assumelines*))
		   (push l *allassumes*))
		  ((and (equal role "type") (> (length name) 4) (equal (subseq name 0 4) "stp_"))
		   (push l (gethash (subseq name 4) *assumelines*))
		   (push l *allassumes*))
		  ((and (equal role "axiom") (> (length name) 10) (equal (subseq name 0 10) "stp_eq_fo_"))
		   (push l (gethash (subseq name 10) *assumelines*))
		   (push l *allassumes*))
		  (t nil)))))
  (close f))

(defun gen-bushy-th0 ()
  (setq *typearity* (make-hash-table :test #'equal))
  (setq *consttpvars* (make-hash-table :test #'equal))
  (setq *consttp* (make-hash-table :test #'equal))
  (setq *foconst* (make-hash-table :test #'equal))
  (setq *proptpvars* (make-hash-table :test #'equal))
  (setq *prop* (make-hash-table :test #'equal))
  (setq *usespecialtypes* t)
  (setq *newspecialtypes* nil)
  (setq *specialtypes* (make-hash-table :test #'equal))
  (setq *specialtypesnamerev* (make-hash-table :test #'equal))
  (set-theories)
  (setq *outputtff0* nil *outputfof* nil)
  (setq *outputthf0* (open "tmp/hol4th0" :direction :output :if-exists :supersede :if-does-not-exist :create))
  (dolist (th theories) (process-theory th "casc_sexpr_hol4/"))
  (close *outputthf0*)
  (set-tables "tmp/hol4th0" "thf")
  (set-conjdeps)
  (dolist (c *conjdeps*)
    (let* ((conjname (cadr c))
	   (axdeps (caddr c))
	   (sigdeps (remove-duplicates (append (gethash conjname *sigdeps*) (apply #'append (mapcar #'(lambda (z) (gethash z *sigdeps*)) axdeps))) :test #'equal))
	   (f nil))
      (setq f (open (format nil "bushy_th0/~d.p" conjname) :direction :output :if-exists :supersede))
      (format f "include('Axioms/HL4001^2.ax').~%")
      (output-sigdeps f sigdeps nil)
      (dolist (x axdeps)
	(dolist (l (reverse (gethash x *assumelines*))) (format f "~d~%" l)))
      (format f "~d~%" (gethash conjname *conjline*))
      (close f))))

(defun gen-bushy-tf0 ()
  (setq *typearity* (make-hash-table :test #'equal))
  (setq *consttpvars* (make-hash-table :test #'equal))
  (setq *consttp* (make-hash-table :test #'equal))
  (setq *foconst* (make-hash-table :test #'equal))
  (setq *proptpvars* (make-hash-table :test #'equal))
  (setq *prop* (make-hash-table :test #'equal))
  (setq *usespecialtypes* t)
  (setq *newspecialtypes* nil)
  (setq *specialtypes* (make-hash-table :test #'equal))
  (setq *specialtypesnamerev* (make-hash-table :test #'equal))
  (set-theories)
  (setq *outputthf0* nil *outputfof* nil)
  (setq *outputtff0* (open "tmp/hol4tf0" :direction :output :if-exists :supersede :if-does-not-exist :create))
  (dolist (th theories) (process-theory th "casc_sexpr_hol4/"))
  (close *outputtff0*)
  (set-tables "tmp/hol4tf0" "tff")
  (set-conjdeps)
  (dolist (c *conjdeps*)
    (let* ((conjname (cadr c))
	   (axdeps (caddr c))
	   (sigdeps (remove-duplicates (append (gethash conjname *sigdeps*) (apply #'append (mapcar #'(lambda (z) (gethash z *sigdeps*)) axdeps))) :test #'equal))
	   (f nil))
      (setq f (open (format nil "bushy_tf0/~d.p" conjname) :direction :output :if-exists :supersede))
      (format f "include('Axioms/HL4001_2.ax').~%")
      (output-sigdeps f sigdeps nil)
      (dolist (x axdeps)
	(dolist (l (reverse (gethash x *assumelines*))) (format f "~d~%" l)))
      (format f "~d~%" (gethash conjname *conjline*))
      (close f))))

(defun gen-bushy-fof ()
  (setq *typearity* (make-hash-table :test #'equal))
  (setq *consttpvars* (make-hash-table :test #'equal))
  (setq *consttp* (make-hash-table :test #'equal))
  (setq *foconst* (make-hash-table :test #'equal))
  (setq *proptpvars* (make-hash-table :test #'equal))
  (setq *prop* (make-hash-table :test #'equal))
  (setq *usespecialtypes* nil)
  (set-theories)
  (setq *outputthf0* nil *outputtff0* nil)
  (setq *outputfof* (open "tmp/hol4fof" :direction :output :if-exists :supersede :if-does-not-exist :create))
  (dolist (th theories) (process-theory th "casc_sexpr_hol4/"))
  (close *outputfof*)
  (set-tables "tmp/hol4fof" "fof")
  (set-conjdeps)
  (dolist (c *conjdeps*)
    (let* ((conjname (cadr c))
	   (axdeps (caddr c))
	   (sigdeps (remove-duplicates (append (gethash conjname *sigdeps*) (apply #'append (mapcar #'(lambda (z) (gethash z *sigdeps*)) axdeps))) :test #'equal))
	   (f nil))
      (setq f (open (format nil "bushy_fof/~d.p" conjname) :direction :output :if-exists :supersede))
      (format f "include('Axioms/HL4001+2.ax').~%")
      (output-sigdeps f sigdeps nil)
      (dolist (x axdeps)
	(dolist (l (reverse (gethash x *assumelines*))) (format f "~d~%" l)))
      (format f "~d~%" (gethash conjname *conjline*))
      (close f))))

(defun copy-file (fin fout)
  (let ((l nil))
    (loop while (setq l (read-line fin nil nil)) do (format fout "~d~%" l))))

(defun gen-chainy-th0 ()
  (setq *typearity* (make-hash-table :test #'equal))
  (setq *consttpvars* (make-hash-table :test #'equal))
  (setq *consttp* (make-hash-table :test #'equal))
  (setq *foconst* (make-hash-table :test #'equal))
  (setq *proptpvars* (make-hash-table :test #'equal))
  (setq *prop* (make-hash-table :test #'equal))
  (setq *usespecialtypes* t)
  (setq *newspecialtypes* nil)
  (setq *specialtypes* (make-hash-table :test #'equal))
  (setq *specialtypesnamerev* (make-hash-table :test #'equal))
  (set-theories)
  (setq *outputtff0* nil *outputfof* nil)
  (setq *prevtheory* "HL4001")
  (dolist (th theories)
    (setq *outputthf0* (open (format nil "Axioms/~d^2.ax" th) :direction :output :if-exists :supersede :if-does-not-exist :create))
    (format *outputthf0* "include('Axioms/~d^2.ax').~%" *prevtheory*)
    (setq *f* (open (format nil "casc_sexpr_hol4/~d" th) :direction :input))
    (loop while (setq l (read *f* nil nil)) do
	  (if (consp l)
	      (case (car l)
		(TYPE_DEFINITION (process-type-decl (cadr l) (caddr l)))
		(CONSTANT_DEFINITION (process-const-decl (cadr l) (caddr l)))
		(AXIOM (process-axiom (cadr l) (caddr l)))
		(CONJECTURE
		 (let ((conjform (process-conj-form (cadr l) (caddr l))))
		   (close *outputthf0*)
		   (setq *f2* (open (format nil "Axioms/~d^2.ax" th) :direction :input))
		   (setq *f3* (open (format nil "chainy_th0/~d.p" (cadr l)) :direction :output :if-exists :supersede :if-does-not-exist :create))
		   (copy-file *f2* *f3*)
		   (close *f2*)
		   (format *f3* "thf(conj_~d,conjecture,~d).~%" (cadr l) conjform)
		   (close *f3*)
		   (setq *outputthf0* (open (format nil "Axioms/~d^2.ax" th) :direction :output :if-exists :append))
		   (format *outputthf0* "thf(conj_~d,lemma,~d).~%" (cadr l) conjform)))
		(t (break)))
	    (break)))
    (close *f*)
    (close *outputthf0*)
    (setq *prevtheory* th))
  )

(defun gen-chainy-tf0 ()
  (setq *typearity* (make-hash-table :test #'equal))
  (setq *consttpvars* (make-hash-table :test #'equal))
  (setq *consttp* (make-hash-table :test #'equal))
  (setq *foconst* (make-hash-table :test #'equal))
  (setq *proptpvars* (make-hash-table :test #'equal))
  (setq *prop* (make-hash-table :test #'equal))
  (setq *usespecialtypes* t)
  (setq *newspecialtypes* nil)
  (setq *specialtypes* (make-hash-table :test #'equal))
  (setq *specialtypesnamerev* (make-hash-table :test #'equal))
  (set-theories)
  (setq *outputthf0* nil *outputfof* nil)
  (setq *prevtheory* "HL4001")
  (dolist (th theories)
    (setq *outputtff0* (open (format nil "Axioms/~d_2.ax" th) :direction :output :if-exists :supersede :if-does-not-exist :create))
    (format *outputtff0* "include('Axioms/~d_2.ax').~%" *prevtheory*)
    (setq *f* (open (format nil "casc_sexpr_hol4/~d" th) :direction :input))
    (loop while (setq l (read *f* nil nil)) do
	  (if (consp l)
	      (case (car l)
		(TYPE_DEFINITION (process-type-decl (cadr l) (caddr l)))
		(CONSTANT_DEFINITION (process-const-decl (cadr l) (caddr l)))
		(AXIOM (process-axiom (cadr l) (caddr l)))
		(CONJECTURE
		 (let ((conjform (process-conj-form (cadr l) (caddr l))))
		   (close *outputtff0*)
		   (setq *f2* (open (format nil "Axioms/~d_2.ax" th) :direction :input))
		   (setq *f3* (open (format nil "chainy_tf0/~d.p" (cadr l)) :direction :output :if-exists :supersede :if-does-not-exist :create))
		   (copy-file *f2* *f3*)
		   (close *f2*)
		   (format *f3* "tff(conj_~d,conjecture,~d).~%" (cadr l) conjform)
		   (close *f3*)
		   (setq *outputtff0* (open (format nil "Axioms/~d_2.ax" th) :direction :output :if-exists :append))
		   (format *outputtff0* "tff(conj_~d,lemma,~d).~%" (cadr l) conjform)))
		(t (break)))
	    (break)))
    (close *f*)
    (close *outputtff0*)
    (setq *prevtheory* th))
  )

(defun gen-chainy-fof ()
  (setq *typearity* (make-hash-table :test #'equal))
  (setq *consttpvars* (make-hash-table :test #'equal))
  (setq *consttp* (make-hash-table :test #'equal))
  (setq *foconst* (make-hash-table :test #'equal))
  (setq *proptpvars* (make-hash-table :test #'equal))
  (setq *prop* (make-hash-table :test #'equal))
  (setq *usespecialtypes* nil)
  (set-theories)
  (setq *outputthf0* nil *outputtff0* nil)
  (setq *prevtheory* "HL4001")
  (dolist (th theories)
    (setq *outputfof* (open (format nil "Axioms/~d+2.ax" th) :direction :output :if-exists :supersede :if-does-not-exist :create))
    (format *outputfof* "include('Axioms/~d+2.ax').~%" *prevtheory*)
    (setq *f* (open (format nil "casc_sexpr_hol4/~d" th) :direction :input))
    (loop while (setq l (read *f* nil nil)) do
	  (if (consp l)
	      (case (car l)
		(TYPE_DEFINITION (process-type-decl (cadr l) (caddr l)))
		(CONSTANT_DEFINITION (process-const-decl (cadr l) (caddr l)))
		(AXIOM (process-axiom (cadr l) (caddr l)))
		(CONJECTURE
		 (let ((conjform (process-conj-form (cadr l) (caddr l))))
		   (close *outputfof*)
		   (setq *f2* (open (format nil "Axioms/~d+2.ax" th) :direction :input))
		   (setq *f3* (open (format nil "chainy_fof/~d.p" (cadr l)) :direction :output :if-exists :supersede :if-does-not-exist :create))
		   (copy-file *f2* *f3*)
		   (close *f2*)
		   (format *f3* "fof(conj_~d,conjecture,~d).~%" (cadr l) conjform)
		   (close *f3*)
		   (setq *outputfof* (open (format nil "Axioms/~d+2.ax" th) :direction :output :if-exists :append))
		   (format *outputfof* "fof(conj_~d,lemma,~d).~%" (cadr l) conjform)))
		(t (break)))
	    (break)))
    (close *f*)
    (close *outputfof*)
    (setq *prevtheory* th))
  )
